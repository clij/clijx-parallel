package net.haesleinhuepf.clijx.parallel;

import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.function.Consumer;

import ij.process.FloatProcessor;
import net.haesleinhuepf.clij.clearcl.ClearCLBuffer;
import net.haesleinhuepf.clij.converters.implementations.ClearCLBufferToRandomAccessibleIntervalConverter;
import net.haesleinhuepf.clij.converters.implementations.RandomAccessibleIntervalToClearCLBufferConverter;
import net.haesleinhuepf.clijx.CLIJx;
import net.imglib2.RandomAccessible;
import net.imglib2.RandomAccessibleInterval;
import net.imglib2.img.array.ArrayImgs;
import net.imglib2.type.NativeType;
import net.imglib2.type.Type;
import net.imglib2.type.numeric.RealType;
import net.imglib2.type.numeric.real.FloatType;
import net.imglib2.util.Intervals;
import net.imglib2.view.Views;

/**
 * A cell loader that fill {@link RandomAccessibleInterval} with data that is
 * generated by CLIJx filters. It automatically selects an idle GPU to process the tile on.
 *
 * @author Stephan Saalfeld, Robert Haase
 * @param <T> output type
 * @param <S> source type
 */
public class CLIJxFilterOp<T extends RealType<T> & NativeType<T>, S extends RealType<S>> implements Consumer<RandomAccessibleInterval<T>> {

    protected final RandomAccessible<S> source;
    protected final long[] padding;
    protected final CLIJxPool clijxPool;
    protected final Class<? extends TileProcessor> klass;

    public CLIJxFilterOp(
            final RandomAccessible<S> source,
            final CLIJxPool clijxPool,
            final Class<? extends TileProcessor> klass,
            final long... padding) {

        this.source = source;
        final int n = source.numDimensions();
        if (n == padding.length)
            this.padding = padding;
        else
            this.padding = Arrays.copyOf(padding, n);
        this.clijxPool = clijxPool;
        this.klass = klass;
    }

    @SuppressWarnings("unchecked")
    @Override
    public void accept(final RandomAccessibleInterval<T> cell) {
        // get a CLIJx instance running on one particular GPU
        CLIJx clijx = clijxPool.getIdleCLIJx();

        // push the image to the GPU
        final RandomAccessibleIntervalToClearCLBufferConverter rai2cl = new RandomAccessibleIntervalToClearCLBufferConverter();
        rai2cl.setCLIJ(clijx.getCLIJ());
        final ClearCLBuffer input = rai2cl.convert(Views.interval(source, Intervals.expand(cell, padding)));
        // create memory on GPU for result image
        final ClearCLBuffer output = clijx.create(input);

        // process the image
        TileProcessor filter;
        try {
            filter = klass.getDeclaredConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        filter.setCLIJx(clijx);
        filter.accept(input, output);

        // pull the result image back
        final ClearCLBufferToRandomAccessibleIntervalConverter cl2rai = new ClearCLBufferToRandomAccessibleIntervalConverter();
        cl2rai.setCLIJ(clijx.getCLIJ());
        final RandomAccessibleInterval<T> result = cl2rai.convert(output);

        // clean up
        input.close();
        output.close();
        clijxPool.setCLIJxIdle(clijx);

        // todo: this is an additional copy-step which might not be necessary
        Util.copyReal(result, Views.translate(Views.zeroMin(cell), padding));
    }


    /**
     * Some useful methods that do not fit elsewhere.
     *
     * @author Stephan Saalfeld
     */
    public interface Util {

        /**
         * Copy the contents of a source {@link RandomAccessible} in an
         * interval defined by and target {@link RandomAccessibleInterval}
         * into that target {@link RandomAccessibleInterval}.
         *
         * @param <T>
         * @param source
         * @param target
         */
        static <T extends Type<T>> void copy(
                final RandomAccessible<? extends T> source,
                final RandomAccessibleInterval<T> target) {

            Views.flatIterable(Views.interval(Views.pair(source, target), target)).forEach(
                    pair -> pair.getB().set(pair.getA()));
        }

        /**
         * Copy the contents of a source {@link RandomAccessible} in an
         * interval defined by and target {@link RandomAccessibleInterval}
         * into that target {@link RandomAccessibleInterval}.
         *
         * @param <T>
         * @param source
         * @param target
         */
        static <T extends RealType<T>, S extends RealType<S>> void copyReal(
                final RandomAccessible<? extends T> source,
                final RandomAccessibleInterval<? extends S> target) {

            Views.flatIterable(Views.interval(Views.pair(source, target), target)).forEach(
                    pair -> pair.getB().setReal(pair.getA().getRealDouble()));
        }

        /**
         * Materialize the first 2D slice of a {@link RandomAccessibleInterval}
         * of {@link FloatType} into a new ImageJ {@link FloatProcessor}.
         *
         * @param source
         * @return
         */
        static FloatProcessor materialize(final RandomAccessibleInterval<FloatType> source) {
            final FloatProcessor target = new FloatProcessor((int) source.dimension(0), (int) source.dimension(1));
            Util.copy(
                    Views.zeroMin(source),
                    ArrayImgs.floats(
                            (float[]) target.getPixels(),
                            target.getWidth(),
                            target.getHeight()));
            return target;
        }
    }
}